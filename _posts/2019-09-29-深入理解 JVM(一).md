---
layout:     post
title:      "深入理解 JVM（一）"
subtitle:   " \"JVM 内部结构\""
date:       2019-09-29 22:04:13
author:     "Tommy"
header-img: "img/post-bg-java.jpg"
catalog: true
tags:
    - Java
    - Interview
---

# 深入浅出 JVM
该篇主要是**深入理解 Java 虚拟机-第二版**的读书笔记总结 - JVM 内部结构。

>**目录**

- [运行时数据区域](#运行时数据区域) 
- [垃圾回收算法](#垃圾回收算法) 
- [垃圾收集器](#垃圾收集器) 

## 运行时数据区域
- 线程私有区域
    - 程序计数器
    - Java 虚拟机栈
    - 本地方法栈
- 线程共享区域
    - Java 堆
    - 方法区
    - 运行时常量池（属于方法区的一部分）

---

### 线程私有区域
#### 程序计数器
程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计算器来完成。

由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。故为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，所以这块内存区域是"线程私有"的区域。

#### Java 虚拟机栈
Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

#### 本地方法栈
本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机栈执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。

---

### 线程共享区域
#### Java 堆
对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被**所有线程共享**的一块内存区域，在虚拟机启动是创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有对象的实例以及数组都要在堆上分配，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有对象都分配在堆上也渐渐变得没那么"绝对"了。

#### 方法区（非堆）
方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把 Java 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non Heap**（非堆），目的应该是与 Java 堆区分开来。

方法区也被开发者成为"永久代"（Permanent Generation）。

#### 运行时常量池（属于方法区的一部分）
Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。


---

## 垃圾回收算法
### 标记-清除（Mark-Sweep）算法
如同名字一样，算法分为"标记"和"清除"两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。

它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。


### 复制算法
为了解决效率问题，复制（Copying）算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样就是每次只对其中一块内存进行回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

这种算法的代价是将内存缩小为了原来的一半，代价很大。这种算法也在特殊场景中会有很大用处，比如回收新生代的时候，IBM 公司的专门研究表明，新生代的对象 98% 是"朝生夕灭"的，所以不需要按照 1:1 的比例来划分内存区域，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor 空间。当回收时，将 Eden 空间和 Survivor 空间中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用过的 Survivor 空间。这里肯定有一个具体空间分配比例，HotSpot 虚拟机默认 Eden:Survivor 为 8:1，也就是每次新生代中可用内存为整个新生代的 90%（80%+10%），只有 10% 的内存会被"浪费"。当然，98% 的对象可回收只是一般场景下的数据，JVM 没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其它内存（这里指老年代）进行分配担保（Handle Promotion）。

内存的分配担保就好比我们现在使用支付宝里面的花呗，如果我们信誉很好，在 98% 的情况下都能按时偿还，于是支付宝会默认我们会在下一月也能按时按量的偿还我们的预支，只需要有一个担保人能保证如果我下次不能还款时，可以帮助你还钱，那支付宝就认为我们预支花呗是没有风险的。内存的分配担保也一样，如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。具体怎么分配担保会在后续分析。

### 标记-整理算法
复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的时，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用复制算法。

根据老年代存活时间较长的特点，有人提出了另一种"标记-整理"（Mark-Compact）的算法，标记过程仍然与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象想一端移动，然后直接清理掉边界以外的内存。

### 分代收集算法
这种算法没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的算法。

- 新生代：复制算法
    
    因为在新生代中，每次垃圾回收时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需付出少量存活对象的复制成本就可以完成收集。

- 老年代：标记-清理/标记-整理
    
    因为老年代对象存活率高、没有额外空间对它进行分配担保。